二叉树解题的思维模式分两类：

1. 是否可以通遍历一遍二叉树得到答案？
   - 用一个**traverse函数配合外部变量**来实现，这叫“遍历”的思维模式。
2. 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？
   - 写出这个递归函数的定义，并充分利用这个函数的返回值，这叫”分解问题“的思维模式。



如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？

其他结点不用你操心，递归函数会帮你在所有结点上执行相同的操作。

```java
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}
```



单链表和数组的遍历可以是迭代的，也可以是递归的，儿叉树这种结构无非就是二叉链表，由于没办法改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式；

**只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后**。

```java
/* 递归遍历单链表，倒序打印链表元素 */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    traverse(head.next);
    // 后序位置
    print(head.val);
}
```

本质上是利用**递归的堆栈**帮你**实现倒序遍历**的效果；



**你可以发现每个节点都有“唯一”属于自己的前中后序位置**，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点；

前序位置的代码在刚刚进入一个二叉树节点的时候执行；

后序位置的代码在将要离开一个二叉树节点的时候执行；

**中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。**

你可以在前序位置写代码往一个List里塞元素，那最后得到的就是前序遍历的结果；但并不是说你就不可以写更复杂的代码做更复杂的事；



二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

> Tips:
>
> 函数命名习惯：二叉树中用遍历思路解题是函数签名一般是void traverse(...)，没有返回值，靠更新外部变量来计算结果，而用分解问题思路解题时函数名根据该函数功能而定，而且一般会有返回值，返回值是子问题的计算结果。



**一颗二叉树的前序遍历结果=根节点+左子树的前序遍历结果+右子树的前序遍历结果。**



前序位置是刚刚进入节点的时刻，后续位置是即将离开节点的时刻；

但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。



一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；

而一个节点为根的整颗子树有多少个节点，你需要遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案；

**一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。**

```java
// 二叉树遍历函数
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // 前序位置
    printf("节点 %s 在第 %d 层", root, level);
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 这样调用
traverse(root, 1);
```

```java
// 定义：输入一棵二叉树，返回这棵二叉树的节点总数
int count(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftCount = count(root.left);
    int rightCount = count(root.right);
    // 后序位置
    printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点",
            root, leftCount, rightCount);

    return leftCount + rightCount + 1;
}
```

